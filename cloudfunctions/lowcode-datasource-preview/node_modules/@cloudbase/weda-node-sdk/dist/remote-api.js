"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchWeda = exports.fetchUrlOld = exports.fetchUrl = exports.getFetchWedaReq = exports.fetchCloud = exports.CloudBaseError = void 0;
const cloud_api_1 = require("@cloudbase/cloud-api");
const config_1 = require("./config");
const common_1 = require("./common");
const common_context_1 = require("./fn-context/common-context");
const node_fetch_1 = __importDefault(require("node-fetch"));
const customLogger = common_1.logger.log.bind(common_1.logger);
class CloudBaseError extends Error {
    constructor(message, options = {}) {
        super();
        this.name = 'CloudBaseError';
        const { code = '', action = '', original = undefined, requestId = '', type, } = options;
        this.message = `[${action}]\nRequestId：${requestId}\n${message}`;
        this.original = original;
        this.code = code;
        this.requestId = requestId;
        this.action = action;
        this.type = type || '';
    }
}
exports.CloudBaseError = CloudBaseError;
/** 请求云API的默认参数 */
const DEFAULT_CLOUD_OPTIONS = {
    service: 'lowcode',
    version: '2021-01-08',
    // 30s
    timeout: 30000,
    data: {},
    capitalizeDataKey: true,
};
/**
 * 请求云API
 * @param params 配置参数
 */
async function fetchCloud(params) {
    try {
        const { TENCENTCLOUD_SECRETID, TENCENTCLOUD_SECRETKEY, TENCENTCLOUD_SESSIONTOKEN, } = (0, config_1.getCloudbaseContext)();
        const newOptions = Object.assign({}, DEFAULT_CLOUD_OPTIONS, params);
        const service = cloud_api_1.CloudApiService.getInstance({
            service: newOptions.service,
            version: newOptions.version,
            credential: {
                secretId: TENCENTCLOUD_SECRETID,
                secretKey: TENCENTCLOUD_SECRETKEY,
                token: TENCENTCLOUD_SESSIONTOKEN,
            },
            timeout: newOptions.timeout,
        });
        const resp = await service.request(params.action, newOptions.capitalizeDataKey
            ? (0, common_1.capitalizeKey)(newOptions.data)
            : newOptions.data);
        return resp;
    }
    catch (error) {
        normalizeCloudAPIError(error, { type: 'design', action: params.action });
    }
}
exports.fetchCloud = fetchCloud;
/** 默认参数 */
const DEFAULT_WEDA_OPTIONS = {
    data: {},
    capitalizeDataKey: true,
    requestId: true,
};
async function getFetchWedaReq(params, ignoreUser, option) {
    let userSource;
    // 忽略用户信息
    //  目前仅获取当前环境的管理员用户id不需要当前用户信息
    if (ignoreUser) {
        userSource = {};
    }
    else if (option === null || option === void 0 ? void 0 : option.useAdmin) {
        userSource = (await (0, common_context_1.getUserSourceCache)({}, { useAdmin: true })) || {};
    }
    else {
        userSource = (0, config_1.getUserSource)();
        if (!userSource || !userSource.uid || !userSource.source) {
            throw new common_1.TCBError('UserError.InvalidUser', common_1.COMMON_ERROR_MESSAGE['UserError.InvalidUser'], {
                reason: `can't get user source, unable to call weda-runtime action ${params.action}`,
            });
        }
    }
    const newParams = Object.assign({}, DEFAULT_WEDA_OPTIONS, params, {
        uid: userSource.uid,
        source: userSource.source,
    });
    delete newParams.serviceType;
    if (newParams.data) {
        const name = newParams.data.name || newParams.data.datasourceName;
        const method = newParams.data.method || newParams.data.methodName;
        newParams.data = Object.assign(Object.assign({}, newParams.data), { name,
            method, datasourceName: name, methodName: method });
    }
    const requestId = newParams.requestId === true
        ? (0, config_1.getConfig)('requestId')
        : newParams.requestId || undefined;
    const cfnParams = (0, config_1.getConfig)('cfnParams');
    const envInfo = (0, config_1.getCloudbaseContext)();
    const requestData = newParams.capitalizeDataKey
        ? (0, common_1.capitalizeKey)(newParams.data)
        : newParams.data;
    const requestParams = Object.assign(Object.assign({}, newParams), { 
        // @ts-ignore
        envType: (0, config_1.getConfig)('envType'), requestId, envId: envInfo.SCF_NAMESPACE, credentials: {
            secretId: envInfo.TENCENTCLOUD_SECRETID,
            secretKey: envInfo.TENCENTCLOUD_SECRETKEY,
            sessionToken: envInfo.TENCENTCLOUD_SESSIONTOKEN,
        }, clientIp: envInfo.TCB_SOURCE_IP || envInfo.WX_CLIENTIP, data: Object.assign({
            WedaAppId: (0, config_1.getConfig)('wedaAppId'),
            AccessToken: (0, config_1.getConfig)('wedaAccessToken'),
        }, requestData, (cfnParams === null || cfnParams === void 0 ? void 0 : cfnParams.Uid) ? { uid: cfnParams.Uid, source: cfnParams.Source } : {}) });
    return requestParams;
}
exports.getFetchWedaReq = getFetchWedaReq;
async function fetchUrl(params, ignoreUser, option) {
    var _a, _b, _c, _d;
    // eslint-disable-next-line prefer-const
    const { isPrivate, tcbHost } = (0, config_1.getConfig)('privateInfo') || {};
    const isTestMode = (0, config_1.getConfig)('isTestMode');
    try {
        const { SCF_NAMESPACE, TCB_SOURCE, WEDA_TOKEN } = (0, config_1.getCloudbaseContext)() || {};
        const requestParams = await getFetchWedaReq(params, ignoreUser, option);
        common_1.logger.log(`[fetchUrl] TCB_SOURCE: ${TCB_SOURCE}`);
        // 透传触发器来源的header
        const headers = {
            'Content-Type': 'application/json; charset=utf-8',
            'x-request-id': requestParams.requestId || '',
            'x-tcb-source': (0, common_1.checkIsInScf)() ? `${TCB_SOURCE || ''},scf` : ',not_scf',
        };
        if ((0, config_1.getTriggerSource)()) {
            headers[config_1.TRIGGER_SOURCE_HEADER] = (0, config_1.getTriggerSource)() || '';
            common_1.logger.log(`[fetchUrl] X-Trigger-Source: ${headers[config_1.TRIGGER_SOURCE_HEADER]}`);
        }
        // 私有化、方法测试场景、sfc内部调用则修改Origin
        if (isPrivate || isTestMode || ((_b = (_a = TCB_SOURCE === null || TCB_SOURCE === void 0 ? void 0 : TCB_SOURCE.split(',')) === null || _a === void 0 ? void 0 : _a.reverse()) === null || _b === void 0 ? void 0 : _b[0]) !== 'web_client' || headers[config_1.TRIGGER_SOURCE_HEADER] === 'flow') {
            headers.Origin = 'http://127.0.0.1';
            headers.Referer = `http://127.0.0.1?triggerSource=${headers[config_1.TRIGGER_SOURCE_HEADER]}&tcbSource=${TCB_SOURCE}&env=${SCF_NAMESPACE}`;
        }
        const envType = (0, config_1.getConfig)('envType');
        const url = tcbHost ? `${tcbHost}/web?env=${SCF_NAMESPACE}` : (0, config_1.getConfig)('wedaTarget') || '';
        const requestData = JSON.parse(JSON.stringify(requestParams));
        delete requestData.data;
        delete requestData.credentials;
        delete requestData.capitalizeDataKey;
        common_1.logger.log(`[fetchUrl] request, request target: ${url}`);
        const body = {
            access_token: (0, config_1.getConfig)('wedaAccessToken') || (requestParams.source === 2 ? WEDA_TOKEN : ''),
            action: 'functions.invokeFunction',
            dataVersion: '2020-01-10',
            env: SCF_NAMESPACE,
            function_name: { pre: 'lowcode-datasource-preview', prod: 'lowcode-datasource' }[envType || 'pre'] || 'lowcode-datasource-preview',
            request_data: JSON.stringify(Object.assign(Object.assign(Object.assign({ mode: 'scf' }, requestParams === null || requestParams === void 0 ? void 0 : requestParams.data), (_c = requestParams === null || requestParams === void 0 ? void 0 : requestParams.data) === null || _c === void 0 ? void 0 : _c.data), (0, common_1.capitalizeKey)(requestData))),
        };
        common_1.logger.log('[fetchUrl] raw params: ', Object.assign(Object.assign({}, body), { access_token: body.access_token
                ? '<masked credentials>'
                : '<no credentials provided>' }));
        let resp = await (0, node_fetch_1.default)(url, {
            method: 'POST',
            headers,
            body: JSON.stringify(body),
        });
        // 公有云环境中，新链路请求失败则使用旧链路
        if (+resp.status !== 200 && !isPrivate) {
            common_1.logger.log('[fetchUrl] after error, status:', resp === null || resp === void 0 ? void 0 : resp.status, 'raw response:', resp);
            return await fetchUrlOld(params, ignoreUser, option);
        }
        resp = await resp.json();
        const { data = {} } = JSON.parse(((_d = resp === null || resp === void 0 ? void 0 : resp.data) === null || _d === void 0 ? void 0 : _d.response_data) || '{}');
        common_1.logger.log('[fetchUrl] after request, requestId:', resp === null || resp === void 0 ? void 0 : resp.requestId, 'raw response:', data);
        if (!!(resp === null || resp === void 0 ? void 0 : resp.code)) {
            throw new CloudBaseError(resp.message, {
                action: params.action,
                requestId: resp === null || resp === void 0 ? void 0 : resp.requestId,
                code: resp.code,
                original: resp,
            });
        }
        if (!!data.code) {
            throw new CloudBaseError(data.message, {
                action: params.action,
                requestId: resp === null || resp === void 0 ? void 0 : resp.requestId,
                code: data.code,
                original: data,
            });
        }
        return data;
    }
    catch (e) {
        if (e.name === 'CloudBaseError') {
            throw e;
        }
        else {
            throw new CloudBaseError(e.message, {
                action: params.action,
                code: e.code,
                type: e.type,
            });
        }
    }
}
exports.fetchUrl = fetchUrl;
async function fetchUrlOld(params, ignoreUser, option) {
    const { serviceType } = params;
    const requestParams = await getFetchWedaReq(params, ignoreUser, option);
    // 透传触发器来源的header
    const headers = {};
    if ((0, config_1.getTriggerSource)()) {
        headers[config_1.TRIGGER_SOURCE_HEADER] = (0, config_1.getTriggerSource)();
    }
    return await (0, cloud_api_1.wedaRequest)(requestParams, {
        // @ts-ignore
        serviceType,
        target: (0, config_1.getConfig)('wedaTarget'),
        logger: customLogger,
        proxy: process.env.WEDA_PROXY,
        headers,
    });
}
exports.fetchUrlOld = fetchUrlOld;
/**
 * 请求Weda后台接口
 * @param params 配置参数
 * @param ignoreUser 是否跳过用户信息校验
 */
async function fetchWeda(params, ignoreUser, option) {
    const { isPrivate, tcbHost } = (0, config_1.getConfig)('privateInfo') || {};
    try {
        let resp = {};
        // 私有化环境，或者配置了url则走新方式请求
        if (isPrivate || tcbHost) {
            resp = await fetchUrl(params, ignoreUser, option);
        }
        else {
            resp = await fetchUrlOld(params, ignoreUser, option);
        }
        return resp;
    }
    catch (error) {
        normalizeCloudAPIError(error, { type: 'runtime', action: params.action });
    }
}
exports.fetchWeda = fetchWeda;
/** 标准花错误信息 */
function normalizeCloudAPIError(error, options) {
    var _a;
    const reason = `failed to weda-${options.type} action ${options.action} on env ${(0, config_1.getConfig)('wedaTarget') || 'prod'}`;
    if (error.name === 'CloudBaseError') {
        const extraMsg = error.requestId ? ` [requestId]${error.requestId}` : '';
        let errorCode = `InnerError.${error.code || 'Unknown'}`;
        // 已有多层错误码的, 不再加前缀
        if (typeof error.code === 'string' && error.code.split('.').length > 1) {
            errorCode = error.code;
        }
        throw new common_1.TCBError(errorCode, (((_a = error === null || error === void 0 ? void 0 : error.original) === null || _a === void 0 ? void 0 : _a.Message) || (error === null || error === void 0 ? void 0 : error.message) || errorCode) + extraMsg, {
            original: error,
            reason: `${reason}, ${error.original ? JSON.stringify(error.original) : ''} ${extraMsg}`,
        });
    }
    if (error.name === 'TCBError')
        throw error;
    throw new common_1.TCBError('InnerError', `请求微搭后台失败, ${error.message}`, {
        original: error,
        reason: `${reason}, ${error.name} ${error.message}`,
    });
}
